{{"language":"Solidity","sources":{"/contracts/SimpleTokenProxy.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.6;\n\nimport \"./interfaces/ICrossChainBridge.sol\";\n\ncontract SimpleTokenProxy {\n\n    bytes32 private constant BEACON_SLOT = bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1);\n\n    fallback() external {\n        address bridge;\n        bytes32 slot = BEACON_SLOT;\n        assembly {\n            bridge := sload(slot)\n        }\n        address impl = ICrossChainBridge(bridge).getTokenImplementation();\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n            let result := delegatecall(gas(), impl, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            switch result\n            case 0 {revert(0, returndatasize())}\n            default {return (0, returndatasize())}\n        }\n    }\n\n    function setBeacon(address newBeacon) external {\n        address beacon;\n        bytes32 slot = BEACON_SLOT;\n        assembly {\n            beacon := sload(slot)\n        }\n        require(beacon == address(0x00));\n        assembly {\n            sstore(slot, newBeacon)\n        }\n    }\n}\n\nlibrary SimpleTokenProxyUtils {\n\n    bytes constant internal SIMPLE_TOKEN_PROXY_BYTECODE = hex\"608060405234801561001057600080fd5b50610215806100206000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c8063d42afb56146100fd575b60008061005960017fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d516101a2565b60001b9050805491506000826001600160a01b031663709bc7f36040518163ffffffff1660e01b8152600401602060405180830381600087803b15801561009f57600080fd5b505af11580156100b3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906100d79190610185565b90503660008037600080366000845af43d6000803e8080156100f8573d6000f35b3d6000fd5b61011061010b366004610161565b610112565b005b60008061014060017fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d516101a2565b8054925090506001600160a01b0382161561015a57600080fd5b9190915550565b60006020828403121561017357600080fd5b813561017e816101c7565b9392505050565b60006020828403121561019757600080fd5b815161017e816101c7565b6000828210156101c257634e487b7160e01b600052601160045260246000fd5b500390565b6001600160a01b03811681146101dc57600080fd5b5056fea2646970667358221220e6ae4b3dc2474e43ff609e19eb520ce54b6f38170a43a6f96541360be5efc2b464736f6c63430008060033\";\n\n    bytes32 constant internal SIMPLE_TOKEN_PROXY_HASH = keccak256(SIMPLE_TOKEN_PROXY_BYTECODE);\n\n    bytes4 constant internal SET_META_DATA_SIG = bytes4(keccak256(\"initAndObtainOwnership(bytes32,bytes32,uint256,address)\"));\n    bytes4 constant internal SET_BEACON_SIG = bytes4(keccak256(\"setBeacon(address)\"));\n\n    function deploySimpleTokenProxy(address bridge, bytes32 salt, ICrossChainBridge.Metadata memory metaData) internal returns (address) {\n        /* lets concat bytecode with constructor parameters */\n        bytes memory bytecode = SIMPLE_TOKEN_PROXY_BYTECODE;\n        /* deploy new contract and store contract address in result variable */\n        address result;\n        assembly {\n            result := create2(0, add(bytecode, 0x20), mload(bytecode), salt)\n        }\n        require(result != address(0x00), \"deploy failed\");\n        /* setup impl */\n        (bool success,) = result.call(abi.encodePacked(SET_BEACON_SIG, abi.encode(bridge)));\n        require(success, \"setBeacon failed\");\n        /* setup meta data */\n        (success,) = result.call(abi.encodePacked(SET_META_DATA_SIG, abi.encode(metaData)));\n        require(success, \"set metadata failed\");\n        /* return generated contract address */\n        return result;\n    }\n\n    function simpleTokenProxyAddress(address deployer, bytes32 salt) internal pure returns (address) {\n        bytes32 bytecodeHash = keccak256(SIMPLE_TOKEN_PROXY_BYTECODE);\n        bytes32 hash = keccak256(abi.encodePacked(uint8(0xff), address(deployer), salt, bytecodeHash));\n        return address(bytes20(hash << 96));\n    }\n}\n"},"/contracts/interfaces/IERC20.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IERC20Mintable {\n\n    function mint(address account, uint256 amount) external;\n\n    function burn(address account, uint256 amount) external;\n}\n\ninterface IERC20Pegged {\n\n    function getOrigin() external view returns (uint256, address);\n}\n\ninterface IERC20Extra {\n\n    function name() external returns (string memory);\n\n    function decimals() external returns (uint8);\n\n    function symbol() external returns (string memory);\n}\n\ninterface IERC20MetadataChangeable {\n\n    event NameChanged(string prevValue, string newValue);\n\n    event SymbolChanged(string prevValue, string newValue);\n\n    function changeName(bytes32) external;\n\n    function changeSymbol(bytes32) external;\n}\n\ninterface IERC20InternetBond {\n\n    function ratio() external view returns (uint256);\n\n    function isRebasing() external view returns (bool);\n}\n"},"/contracts/interfaces/ICrossChainBridge.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.6;\n\nimport \"../interfaces/IERC20.sol\";\n\ninterface ICrossChainBridge {\n\n    event ContractAllowed(address contractAddress, uint256 toChain);\n    event ContractDisallowed(address contractAddress, uint256 toChain);\n    event ConsensusChanged(address consensusAddress);\n    event TokenImplementationChanged(address consensusAddress);\n    event BondImplementationChanged(address consensusAddress);\n\n    struct Metadata {\n        bytes32 symbol;\n        bytes32 name;\n        uint256 originChain;\n        address originAddress;\n        bytes32 bondMetadata; // encoded metadata version, bond type\n    }\n\n    event DepositLocked(\n        uint256 chainId,\n        address indexed fromAddress,\n        address indexed toAddress,\n        address fromToken,\n        address toToken,\n        uint256 totalAmount,\n        Metadata metadata\n    );\n    event DepositBurned(\n        uint256 chainId,\n        address indexed fromAddress,\n        address indexed toAddress,\n        address fromToken,\n        address toToken,\n        uint256 totalAmount,\n        Metadata metadata,\n        address originToken\n    );\n\n    event WithdrawMinted(\n        bytes32 receiptHash,\n        address indexed fromAddress,\n        address indexed toAddress,\n        address fromToken,\n        address toToken,\n        uint256 totalAmount\n    );\n    event WithdrawUnlocked(\n        bytes32 receiptHash,\n        address indexed fromAddress,\n        address indexed toAddress,\n        address fromToken,\n        address toToken,\n        uint256 totalAmount\n    );\n\n    enum InternetBondType {\n        NOT_BOND,\n        REBASING_BOND,\n        NONREBASING_BOND\n    }\n\n    function isPeggedToken(address toToken) external returns (bool);\n\n    function deposit(uint256 toChain, address toAddress) payable external;\n\n    function deposit(address fromToken, uint256 toChain, address toAddress, uint256 amount) external;\n\n    function withdraw(bytes calldata encodedProof, bytes calldata rawReceipt, bytes calldata receiptRootSignature) external;\n\n    function factoryPeggedToken(uint256 fromChain, Metadata calldata metaData) external;\n\n    function factoryPeggedBond(uint256 fromChain, Metadata calldata metaData) external;\n\n    function getTokenImplementation() external returns (address);\n\n    function getBondImplementation() external returns (address);\n\n}\n"},"@openzeppelin/contracts/token/ERC20/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"}},"settings":{"optimizer":{"enabled":true,"runs":200},"outputSelection":{"/contracts/SimpleTokenProxy.sol":{"SimpleTokenProxy":["*"]}}}}}
