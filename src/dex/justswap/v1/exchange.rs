// @generated
// This file was @generated by `substreams-ethereum-abigen`. Do not edit it by hand.

const INTERNAL_ERR: &'static str = "`ethabi_derive` internal error";
/// Contract's functions.
#[allow(dead_code, unused_imports, unused_variables)]
pub mod functions {
    use super::INTERNAL_ERR;
}
/// Contract's events.
#[allow(dead_code, unused_imports, unused_variables)]
pub mod events {
    use super::INTERNAL_ERR;
    #[derive(Debug, Clone, PartialEq)]
    pub struct AddLiquidity {
        pub provider: Vec<u8>,
        pub trx_amount: substreams::scalar::BigInt,
        pub token_amount: substreams::scalar::BigInt,
    }
    impl AddLiquidity {
        const TOPIC_ID: [u8; 32] = [
            6u8, 35u8, 150u8, 83u8, 146u8, 42u8, 199u8, 190u8, 166u8, 170u8, 43u8, 25u8, 220u8,
            72u8, 107u8, 147u8, 97u8, 130u8, 29u8, 55u8, 113u8, 46u8, 183u8, 150u8, 173u8, 253u8,
            56u8, 216u8, 29u8, 226u8, 120u8, 202u8,
        ];
        pub fn match_log(log: &substreams_ethereum::pb::eth::v2::Log) -> bool {
            if log.topics.len() != 4usize {
                return false;
            }
            if log.data.len() != 0usize {
                return false;
            }
            return log.topics.get(0).expect("bounds already checked").as_ref() as &[u8]
                == Self::TOPIC_ID;
        }
        pub fn decode(log: &substreams_ethereum::pb::eth::v2::Log) -> Result<Self, String> {
            Ok(Self {
                provider: ethabi::decode(
                    &[ethabi::ParamType::Address],
                    log.topics[1usize].as_ref(),
                )
                .map_err(|e| {
                    format!(
                        "unable to decode param 'provider' from topic of type 'address': {:?}",
                        e
                    )
                })?
                .pop()
                .expect(INTERNAL_ERR)
                .into_address()
                .expect(INTERNAL_ERR)
                .as_bytes()
                .to_vec(),
                trx_amount: {
                    let mut v = [0 as u8; 32];
                    ethabi::decode(
                            &[ethabi::ParamType::Uint(256usize)],
                            log.topics[2usize].as_ref(),
                        )
                        .map_err(|e| {
                            format!(
                                "unable to decode param 'trx_amount' from topic of type 'uint256': {:?}",
                                e
                            )
                        })?
                        .pop()
                        .expect(INTERNAL_ERR)
                        .into_uint()
                        .expect(INTERNAL_ERR)
                        .to_big_endian(v.as_mut_slice());
                    substreams::scalar::BigInt::from_unsigned_bytes_be(&v)
                },
                token_amount: {
                    let mut v = [0 as u8; 32];
                    ethabi::decode(
                            &[ethabi::ParamType::Uint(256usize)],
                            log.topics[3usize].as_ref(),
                        )
                        .map_err(|e| {
                            format!(
                                "unable to decode param 'token_amount' from topic of type 'uint256': {:?}",
                                e
                            )
                        })?
                        .pop()
                        .expect(INTERNAL_ERR)
                        .into_uint()
                        .expect(INTERNAL_ERR)
                        .to_big_endian(v.as_mut_slice());
                    substreams::scalar::BigInt::from_unsigned_bytes_be(&v)
                },
            })
        }
    }
    impl substreams_ethereum::Event for AddLiquidity {
        const NAME: &'static str = "AddLiquidity";
        fn match_log(log: &substreams_ethereum::pb::eth::v2::Log) -> bool {
            Self::match_log(log)
        }
        fn decode(log: &substreams_ethereum::pb::eth::v2::Log) -> Result<Self, String> {
            Self::decode(log)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct Approval {
        pub owner: Vec<u8>,
        pub spender: Vec<u8>,
        pub value: substreams::scalar::BigInt,
    }
    impl Approval {
        const TOPIC_ID: [u8; 32] = [
            140u8, 91u8, 225u8, 229u8, 235u8, 236u8, 125u8, 91u8, 209u8, 79u8, 113u8, 66u8, 125u8,
            30u8, 132u8, 243u8, 221u8, 3u8, 20u8, 192u8, 247u8, 178u8, 41u8, 30u8, 91u8, 32u8,
            10u8, 200u8, 199u8, 195u8, 185u8, 37u8,
        ];
        pub fn match_log(log: &substreams_ethereum::pb::eth::v2::Log) -> bool {
            if log.topics.len() != 3usize {
                return false;
            }
            if log.data.len() != 32usize {
                return false;
            }
            return log.topics.get(0).expect("bounds already checked").as_ref() as &[u8]
                == Self::TOPIC_ID;
        }
        pub fn decode(log: &substreams_ethereum::pb::eth::v2::Log) -> Result<Self, String> {
            let mut values =
                ethabi::decode(&[ethabi::ParamType::Uint(256usize)], log.data.as_ref())
                    .map_err(|e| format!("unable to decode log.data: {:?}", e))?;
            values.reverse();
            Ok(Self {
                owner: ethabi::decode(&[ethabi::ParamType::Address], log.topics[1usize].as_ref())
                    .map_err(|e| {
                        format!(
                            "unable to decode param 'owner' from topic of type 'address': {:?}",
                            e
                        )
                    })?
                    .pop()
                    .expect(INTERNAL_ERR)
                    .into_address()
                    .expect(INTERNAL_ERR)
                    .as_bytes()
                    .to_vec(),
                spender: ethabi::decode(&[ethabi::ParamType::Address], log.topics[2usize].as_ref())
                    .map_err(|e| {
                        format!(
                            "unable to decode param 'spender' from topic of type 'address': {:?}",
                            e
                        )
                    })?
                    .pop()
                    .expect(INTERNAL_ERR)
                    .into_address()
                    .expect(INTERNAL_ERR)
                    .as_bytes()
                    .to_vec(),
                value: {
                    let mut v = [0 as u8; 32];
                    values
                        .pop()
                        .expect(INTERNAL_ERR)
                        .into_uint()
                        .expect(INTERNAL_ERR)
                        .to_big_endian(v.as_mut_slice());
                    substreams::scalar::BigInt::from_unsigned_bytes_be(&v)
                },
            })
        }
    }
    impl substreams_ethereum::Event for Approval {
        const NAME: &'static str = "Approval";
        fn match_log(log: &substreams_ethereum::pb::eth::v2::Log) -> bool {
            Self::match_log(log)
        }
        fn decode(log: &substreams_ethereum::pb::eth::v2::Log) -> Result<Self, String> {
            Self::decode(log)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct RemoveLiquidity {
        pub provider: Vec<u8>,
        pub trx_amount: substreams::scalar::BigInt,
        pub token_amount: substreams::scalar::BigInt,
    }
    impl RemoveLiquidity {
        const TOPIC_ID: [u8; 32] = [
            15u8, 191u8, 6u8, 192u8, 88u8, 185u8, 12u8, 176u8, 56u8, 166u8, 24u8, 248u8, 194u8,
            172u8, 191u8, 97u8, 69u8, 248u8, 179u8, 87u8, 15u8, 209u8, 250u8, 86u8, 171u8, 184u8,
            240u8, 243u8, 240u8, 91u8, 54u8, 232u8,
        ];
        pub fn match_log(log: &substreams_ethereum::pb::eth::v2::Log) -> bool {
            if log.topics.len() != 4usize {
                return false;
            }
            if log.data.len() != 0usize {
                return false;
            }
            return log.topics.get(0).expect("bounds already checked").as_ref() as &[u8]
                == Self::TOPIC_ID;
        }
        pub fn decode(log: &substreams_ethereum::pb::eth::v2::Log) -> Result<Self, String> {
            Ok(Self {
                provider: ethabi::decode(
                    &[ethabi::ParamType::Address],
                    log.topics[1usize].as_ref(),
                )
                .map_err(|e| {
                    format!(
                        "unable to decode param 'provider' from topic of type 'address': {:?}",
                        e
                    )
                })?
                .pop()
                .expect(INTERNAL_ERR)
                .into_address()
                .expect(INTERNAL_ERR)
                .as_bytes()
                .to_vec(),
                trx_amount: {
                    let mut v = [0 as u8; 32];
                    ethabi::decode(
                            &[ethabi::ParamType::Uint(256usize)],
                            log.topics[2usize].as_ref(),
                        )
                        .map_err(|e| {
                            format!(
                                "unable to decode param 'trx_amount' from topic of type 'uint256': {:?}",
                                e
                            )
                        })?
                        .pop()
                        .expect(INTERNAL_ERR)
                        .into_uint()
                        .expect(INTERNAL_ERR)
                        .to_big_endian(v.as_mut_slice());
                    substreams::scalar::BigInt::from_unsigned_bytes_be(&v)
                },
                token_amount: {
                    let mut v = [0 as u8; 32];
                    ethabi::decode(
                            &[ethabi::ParamType::Uint(256usize)],
                            log.topics[3usize].as_ref(),
                        )
                        .map_err(|e| {
                            format!(
                                "unable to decode param 'token_amount' from topic of type 'uint256': {:?}",
                                e
                            )
                        })?
                        .pop()
                        .expect(INTERNAL_ERR)
                        .into_uint()
                        .expect(INTERNAL_ERR)
                        .to_big_endian(v.as_mut_slice());
                    substreams::scalar::BigInt::from_unsigned_bytes_be(&v)
                },
            })
        }
    }
    impl substreams_ethereum::Event for RemoveLiquidity {
        const NAME: &'static str = "RemoveLiquidity";
        fn match_log(log: &substreams_ethereum::pb::eth::v2::Log) -> bool {
            Self::match_log(log)
        }
        fn decode(log: &substreams_ethereum::pb::eth::v2::Log) -> Result<Self, String> {
            Self::decode(log)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct Snapshot {
        pub operator: Vec<u8>,
        pub trx_balance: substreams::scalar::BigInt,
        pub token_balance: substreams::scalar::BigInt,
    }
    impl Snapshot {
        const TOPIC_ID: [u8; 32] = [
            204u8, 114u8, 68u8, 211u8, 83u8, 94u8, 118u8, 57u8, 54u8, 111u8, 140u8, 82u8, 17u8,
            82u8, 113u8, 18u8, 224u8, 29u8, 227u8, 236u8, 116u8, 73u8, 238u8, 58u8, 110u8, 102u8,
            176u8, 7u8, 244u8, 6u8, 90u8, 112u8,
        ];
        pub fn match_log(log: &substreams_ethereum::pb::eth::v2::Log) -> bool {
            if log.topics.len() != 4usize {
                return false;
            }
            if log.data.len() != 0usize {
                return false;
            }
            return log.topics.get(0).expect("bounds already checked").as_ref() as &[u8]
                == Self::TOPIC_ID;
        }
        pub fn decode(log: &substreams_ethereum::pb::eth::v2::Log) -> Result<Self, String> {
            Ok(Self {
                operator: ethabi::decode(
                    &[ethabi::ParamType::Address],
                    log.topics[1usize].as_ref(),
                )
                .map_err(|e| {
                    format!(
                        "unable to decode param 'operator' from topic of type 'address': {:?}",
                        e
                    )
                })?
                .pop()
                .expect(INTERNAL_ERR)
                .into_address()
                .expect(INTERNAL_ERR)
                .as_bytes()
                .to_vec(),
                trx_balance: {
                    let mut v = [0 as u8; 32];
                    ethabi::decode(
                            &[ethabi::ParamType::Uint(256usize)],
                            log.topics[2usize].as_ref(),
                        )
                        .map_err(|e| {
                            format!(
                                "unable to decode param 'trx_balance' from topic of type 'uint256': {:?}",
                                e
                            )
                        })?
                        .pop()
                        .expect(INTERNAL_ERR)
                        .into_uint()
                        .expect(INTERNAL_ERR)
                        .to_big_endian(v.as_mut_slice());
                    substreams::scalar::BigInt::from_unsigned_bytes_be(&v)
                },
                token_balance: {
                    let mut v = [0 as u8; 32];
                    ethabi::decode(
                            &[ethabi::ParamType::Uint(256usize)],
                            log.topics[3usize].as_ref(),
                        )
                        .map_err(|e| {
                            format!(
                                "unable to decode param 'token_balance' from topic of type 'uint256': {:?}",
                                e
                            )
                        })?
                        .pop()
                        .expect(INTERNAL_ERR)
                        .into_uint()
                        .expect(INTERNAL_ERR)
                        .to_big_endian(v.as_mut_slice());
                    substreams::scalar::BigInt::from_unsigned_bytes_be(&v)
                },
            })
        }
    }
    impl substreams_ethereum::Event for Snapshot {
        const NAME: &'static str = "Snapshot";
        fn match_log(log: &substreams_ethereum::pb::eth::v2::Log) -> bool {
            Self::match_log(log)
        }
        fn decode(log: &substreams_ethereum::pb::eth::v2::Log) -> Result<Self, String> {
            Self::decode(log)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct TokenPurchase {
        pub buyer: Vec<u8>,
        pub trx_sold: substreams::scalar::BigInt,
        pub tokens_bought: substreams::scalar::BigInt,
    }
    impl TokenPurchase {
        const TOPIC_ID: [u8; 32] = [
            205u8, 96u8, 170u8, 117u8, 222u8, 163u8, 7u8, 47u8, 188u8, 7u8, 174u8, 109u8, 125u8,
            133u8, 107u8, 93u8, 197u8, 244u8, 238u8, 232u8, 136u8, 84u8, 245u8, 180u8, 171u8,
            247u8, 182u8, 128u8, 239u8, 139u8, 197u8, 15u8,
        ];
        pub fn match_log(log: &substreams_ethereum::pb::eth::v2::Log) -> bool {
            if log.topics.len() != 4usize {
                return false;
            }
            if log.data.len() != 0usize {
                return false;
            }
            return log.topics.get(0).expect("bounds already checked").as_ref() as &[u8]
                == Self::TOPIC_ID;
        }
        pub fn decode(log: &substreams_ethereum::pb::eth::v2::Log) -> Result<Self, String> {
            Ok(Self {
                buyer: ethabi::decode(&[ethabi::ParamType::Address], log.topics[1usize].as_ref())
                    .map_err(|e| {
                        format!(
                            "unable to decode param 'buyer' from topic of type 'address': {:?}",
                            e
                        )
                    })?
                    .pop()
                    .expect(INTERNAL_ERR)
                    .into_address()
                    .expect(INTERNAL_ERR)
                    .as_bytes()
                    .to_vec(),
                trx_sold: {
                    let mut v = [0 as u8; 32];
                    ethabi::decode(
                        &[ethabi::ParamType::Uint(256usize)],
                        log.topics[2usize].as_ref(),
                    )
                    .map_err(|e| {
                        format!(
                            "unable to decode param 'trx_sold' from topic of type 'uint256': {:?}",
                            e
                        )
                    })?
                    .pop()
                    .expect(INTERNAL_ERR)
                    .into_uint()
                    .expect(INTERNAL_ERR)
                    .to_big_endian(v.as_mut_slice());
                    substreams::scalar::BigInt::from_unsigned_bytes_be(&v)
                },
                tokens_bought: {
                    let mut v = [0 as u8; 32];
                    ethabi::decode(
                            &[ethabi::ParamType::Uint(256usize)],
                            log.topics[3usize].as_ref(),
                        )
                        .map_err(|e| {
                            format!(
                                "unable to decode param 'tokens_bought' from topic of type 'uint256': {:?}",
                                e
                            )
                        })?
                        .pop()
                        .expect(INTERNAL_ERR)
                        .into_uint()
                        .expect(INTERNAL_ERR)
                        .to_big_endian(v.as_mut_slice());
                    substreams::scalar::BigInt::from_unsigned_bytes_be(&v)
                },
            })
        }
    }
    impl substreams_ethereum::Event for TokenPurchase {
        const NAME: &'static str = "TokenPurchase";
        fn match_log(log: &substreams_ethereum::pb::eth::v2::Log) -> bool {
            Self::match_log(log)
        }
        fn decode(log: &substreams_ethereum::pb::eth::v2::Log) -> Result<Self, String> {
            Self::decode(log)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct Transfer {
        pub from: Vec<u8>,
        pub to: Vec<u8>,
        pub value: substreams::scalar::BigInt,
    }
    impl Transfer {
        const TOPIC_ID: [u8; 32] = [
            221u8, 242u8, 82u8, 173u8, 27u8, 226u8, 200u8, 155u8, 105u8, 194u8, 176u8, 104u8,
            252u8, 55u8, 141u8, 170u8, 149u8, 43u8, 167u8, 241u8, 99u8, 196u8, 161u8, 22u8, 40u8,
            245u8, 90u8, 77u8, 245u8, 35u8, 179u8, 239u8,
        ];
        pub fn match_log(log: &substreams_ethereum::pb::eth::v2::Log) -> bool {
            if log.topics.len() != 3usize {
                return false;
            }
            if log.data.len() != 32usize {
                return false;
            }
            return log.topics.get(0).expect("bounds already checked").as_ref() as &[u8]
                == Self::TOPIC_ID;
        }
        pub fn decode(log: &substreams_ethereum::pb::eth::v2::Log) -> Result<Self, String> {
            let mut values =
                ethabi::decode(&[ethabi::ParamType::Uint(256usize)], log.data.as_ref())
                    .map_err(|e| format!("unable to decode log.data: {:?}", e))?;
            values.reverse();
            Ok(Self {
                from: ethabi::decode(&[ethabi::ParamType::Address], log.topics[1usize].as_ref())
                    .map_err(|e| {
                        format!(
                            "unable to decode param 'from' from topic of type 'address': {:?}",
                            e
                        )
                    })?
                    .pop()
                    .expect(INTERNAL_ERR)
                    .into_address()
                    .expect(INTERNAL_ERR)
                    .as_bytes()
                    .to_vec(),
                to: ethabi::decode(&[ethabi::ParamType::Address], log.topics[2usize].as_ref())
                    .map_err(|e| {
                        format!(
                            "unable to decode param 'to' from topic of type 'address': {:?}",
                            e
                        )
                    })?
                    .pop()
                    .expect(INTERNAL_ERR)
                    .into_address()
                    .expect(INTERNAL_ERR)
                    .as_bytes()
                    .to_vec(),
                value: {
                    let mut v = [0 as u8; 32];
                    values
                        .pop()
                        .expect(INTERNAL_ERR)
                        .into_uint()
                        .expect(INTERNAL_ERR)
                        .to_big_endian(v.as_mut_slice());
                    substreams::scalar::BigInt::from_unsigned_bytes_be(&v)
                },
            })
        }
    }
    impl substreams_ethereum::Event for Transfer {
        const NAME: &'static str = "Transfer";
        fn match_log(log: &substreams_ethereum::pb::eth::v2::Log) -> bool {
            Self::match_log(log)
        }
        fn decode(log: &substreams_ethereum::pb::eth::v2::Log) -> Result<Self, String> {
            Self::decode(log)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct TrxPurchase {
        pub buyer: Vec<u8>,
        pub tokens_sold: substreams::scalar::BigInt,
        pub trx_bought: substreams::scalar::BigInt,
    }
    impl TrxPurchase {
        const TOPIC_ID: [u8; 32] = [
            218u8, 217u8, 236u8, 92u8, 155u8, 156u8, 130u8, 191u8, 105u8, 39u8, 191u8, 11u8, 100u8,
            41u8, 61u8, 205u8, 209u8, 248u8, 44u8, 146u8, 121u8, 58u8, 239u8, 60u8, 95u8, 38u8,
            215u8, 185u8, 58u8, 74u8, 83u8, 6u8,
        ];
        pub fn match_log(log: &substreams_ethereum::pb::eth::v2::Log) -> bool {
            if log.topics.len() != 4usize {
                return false;
            }
            if log.data.len() != 0usize {
                return false;
            }
            return log.topics.get(0).expect("bounds already checked").as_ref() as &[u8]
                == Self::TOPIC_ID;
        }
        pub fn decode(log: &substreams_ethereum::pb::eth::v2::Log) -> Result<Self, String> {
            Ok(Self {
                buyer: ethabi::decode(&[ethabi::ParamType::Address], log.topics[1usize].as_ref())
                    .map_err(|e| {
                        format!(
                            "unable to decode param 'buyer' from topic of type 'address': {:?}",
                            e
                        )
                    })?
                    .pop()
                    .expect(INTERNAL_ERR)
                    .into_address()
                    .expect(INTERNAL_ERR)
                    .as_bytes()
                    .to_vec(),
                tokens_sold: {
                    let mut v = [0 as u8; 32];
                    ethabi::decode(
                            &[ethabi::ParamType::Uint(256usize)],
                            log.topics[2usize].as_ref(),
                        )
                        .map_err(|e| {
                            format!(
                                "unable to decode param 'tokens_sold' from topic of type 'uint256': {:?}",
                                e
                            )
                        })?
                        .pop()
                        .expect(INTERNAL_ERR)
                        .into_uint()
                        .expect(INTERNAL_ERR)
                        .to_big_endian(v.as_mut_slice());
                    substreams::scalar::BigInt::from_unsigned_bytes_be(&v)
                },
                trx_bought: {
                    let mut v = [0 as u8; 32];
                    ethabi::decode(
                            &[ethabi::ParamType::Uint(256usize)],
                            log.topics[3usize].as_ref(),
                        )
                        .map_err(|e| {
                            format!(
                                "unable to decode param 'trx_bought' from topic of type 'uint256': {:?}",
                                e
                            )
                        })?
                        .pop()
                        .expect(INTERNAL_ERR)
                        .into_uint()
                        .expect(INTERNAL_ERR)
                        .to_big_endian(v.as_mut_slice());
                    substreams::scalar::BigInt::from_unsigned_bytes_be(&v)
                },
            })
        }
    }
    impl substreams_ethereum::Event for TrxPurchase {
        const NAME: &'static str = "TrxPurchase";
        fn match_log(log: &substreams_ethereum::pb::eth::v2::Log) -> bool {
            Self::match_log(log)
        }
        fn decode(log: &substreams_ethereum::pb::eth::v2::Log) -> Result<Self, String> {
            Self::decode(log)
        }
    }
}
